# Anchor 语言编译器

这是一个功能完备的编译器课程设计项目，旨在实现一个名为 "Anchor" 的自定义编程语言。该编译器覆盖了从前端到后端的完整流程，包括词法分析、语法分析、语义分析、中间代码生成与优化，并最终生成可执行的 x86 汇编代码。

---

## 目录

- [项目特色](#项目特色)
- [Anchor 语言规范](#anchor-语言规范)
  - [数据类型](#数据类型)
  - [变量与声明](#变量与声明)
  - [操作符](#操作符)
  - [控制流](#控制流)
  - [函数](#函数)
  - [内置函数 (输入/输出)](#内置函数-输入输出)
  - [注释](#注释)
- [项目结构](#项目结构)
- [编译流程详解](#编译流程详解)
  - [1. 词法分析 (Lexical Analysis)](#1-词法分析-lexical-analysis)
  - [2. 语法分析 (Syntax Analysis)](#2-语法分析-syntax-analysis)
  - [3. 中间代码生成 (IR Generation)](#3-中间代码生成-ir-generation)
  - [4. 中间代码优化 (Optimization)](#4-中间代码优化-optimization)
  - [5. 目标代码生成 (Code Generation)](#5-目标代码生成-code-generation)
- [如何构建与运行](#如何构建与运行)
  - [环境依赖](#环境依赖)
  - [构建步骤](#构建步骤)
  - [运行步骤](#运行步骤)

---

## 项目特色

- **完整的编译流程**: 实现了从源代码到目标汇编代码的全套编译流程。
- **前端技术**:
  - **词法分析**: 手动实现的高效词法分析器，可将源代码分解为 Token 流。
  - **语法分析**: 采用递归下降（Recursive Descent）的语法分析方法，构建抽象语法树（AST）。
- **后端技术**:
  - **中间表示**: 使用四元式作为中间表示（IR），清晰地表达程序逻辑。
  - **代码优化**: 实现了基于有向无环图（DAG）的局部代码优化策略，以提升生成代码的效率。
  - **目标代码生成**: 将优化后的四元式翻译为 x86 汇编代码。
- **模块化设计**: 项目结构清晰，各个模块（如 `Scanner`, `Parser`, `Optimizer`）职责分明，易于理解和扩展。
- **用户友好的交互**: 集成了 `tinyfiledialogs` 库，提供图形化界面供用户选择需要编译的源文件。

---

## Anchor 语言规范

Anchor 是一种静态类型的过程式编程语言，其语法部分借鉴了 C/C++。

### 数据类型

- **基本类型**:
  - `int`: 整数类型。
  - `float`: 浮点数类型。
  - `bool`: 布尔类型，值为 `true` 或 `false`。
  - `char`: 字符类型，使用单引号（例如 `'a'`）。
  - `string`: 字符串类型，使用双引号（例如 `"hello"`）。
  - `void`: 空类型，用于函数返回值。
- **复合类型**:
  - **数组**: 支持 C 风格的静态数组 (`int arr[10];`) 和更灵活的动态风格数组 (`int[]`)。
  - **结构体 (`struct`)**: 允许用户自定义复合数据结构。

### 变量与声明

变量在使用前必须声明其类型，支持在声明时初始化。

```c
int a = 10;
float pi = 3.14;
bool flag = true;
string message = "Hello, Anchor!";
int arr[10]; // 声明一个包含10个整数的静态数组
````

### 操作符

支持丰富的算术、关系、逻辑和赋值操作符。

  - **算术**: `+`, `-`, `*`, `/`, `%`
  - **关系**: `==`, `!=`, `>`, `<`, `>=`, `<=`
  - **逻辑**: `&&`, `||`, `!`
  - **赋值**: `=`

### 控制流

  - **条件语句**: `if-else` 结构。
    ```c
    if (a > 5) {
        print("Greater than 5");
    } else {
        print("Not greater than 5");
    }
    ```
  - **循环语句**: 支持 `while` 和 `for` 循环。
    ```c
    // while 循环
    int i = 0;
    while (i < 10) {
        i = i + 1;
    }

    // for 循环
    for (int j = 0; j < 5; j = j + 1) {
        print(j);
    }
    ```
  - **选择语句**: `switch` 语句，其行为具有“贯穿”（fall-through）特性，需使用 `break` 显式跳出。
    ```c
    switch (day) {
        case 1:
            print("Monday");
            break; // 若无 break，会继续执行 case 2 的代码
        case 2:
            print("Tuesday");
            break;
        default:
            print("Other day");
    }
    ```
  - **流程控制**: `break` 和 `continue`。
      - `break`: 跳出当前循环或 `switch` 语句。
      - `continue`: 结束当前循环的迭代，进入下一次迭代。

### 函数

函数需指定返回类型、函数名和参数列表。

```c
// 定义一个函数
int add(int a, int b) {
    return a + b;
}

// 定义一个无返回值的函数
void say_hello() {
    print("Hello, World!");
}

// 调用函数
int result = add(5, 3);
say_hello();
```

### 内置函数 (输入/输出)

  - `print(expression)`: 在控制台打印表达式的值。
  - `read()`: 从控制台读取一个整数值。

### 注释

  - **单行注释**: 使用 `//`
  - **多行注释**: 使用 `/* ... */`

-----

## 项目结构

项目采用模块化设计，核心组件分离在不同的文件中，职责清晰。

| 文件/模块 | 描述 |
| :--- | :--- |
| `main.cpp` | 程序入口，负责串联编译的各个阶段，并调用图形化文件选择器。 |
| `scanner.h/.cpp` | **词法分析器**：读取源代码，将其分解为 Token 序列。 |
| `parser.h/.cpp` | **语法分析器**：采用递归下降法，根据 Token 序列构建抽象语法树(AST)。 |
| `ast_nodes.h/.cpp` | 定义了构成抽象语法树（AST）的各类节点结构。 |
| `symbol_table.h/.cpp` | **符号表**：用于管理变量、函数等标识符的类型、作用域等信息。 |
| `ir_generator.h/.cpp` | **中间代码生成器**：遍历 AST，生成四元式中间表示（IR）。 |
| `quadruple.h` | 定义了四元式的结构。 |
| `optimizer.h/.cpp` | **优化器**：负责对生成的四元式进行优化（如DAG优化）。 |
| `code_generator.h/.cpp` | **目标代码生成器**：将（优化后的）四元式翻译成 x86 汇编代码。 |
| `token.h/.cpp` | 定义了 Token 结构和所有 Token 类型。 |
| `tinyfiledialogs.h/.c` | 第三方库，用于实现跨平台的图形化文件对话框。 |
| `CMakeLists.txt` | 项目的构建配置文件。 |

-----

## 编译流程详解

本编译器遵循经典的多阶段编译模型：

### 1\. 词法分析 (Lexical Analysis)

  - **输入**: Anchor 源代码文件。
  - **处理**: `Scanner` 模块逐字符读取源代码，识别出关键字、标识符、字面量（整数、字符串等）、操作符和界符。它会忽略空白字符和注释。
  - **输出**: 一系列 Token 组成的流，每个 Token 都包含类型和（可选的）值。

### 2\. 语法分析 (Syntax Analysis)

  - **输入**: Token 流。
  - **处理**: `Parser` 模块采用递归下降的分析方法。它根据 Anchor 语言的语法规则消费 Token 流，并在内存中构建一棵抽象语法树（AST）。AST 的每个节点都对应源代码中的一个语法结构（如表达式、语句、函数定义等）。在此阶段，`SymbolTable` 被用来记录和查询变量/函数的定义，进行基本的语义检查（如变量重定义）。
  - **输出**: 完整的抽象语法树（AST）。

### 3\. 中间代码生成 (IR Generation)

  - **输入**: 抽象语法树（AST）。
  - **处理**: `IRGenerator` 模块通过深度优先遍历 AST，将树形结构线性化。对于每个节点，它会生成一条或多条**四元式**。四元式是一种三地址代码，形式为 `(operator, argument1, argument2, result)`，能够清晰地表达计算和控制流。
  - **输出**: 一系列的四元式指令。

### 4\. 中间代码优化 (Optimization)

  - **输入**: 原始的四元式序列。
  - **处理**: 这是编译器的关键部分。`Optimizer` 模块首先将四元式序列划分为**基本块**（Basic Blocks）。然后，它在每个基本块内部应用基于**有向无环图（DAG）** 的局部优化算法，以消除公共子表达式和冗余计算。
  - **输出**: 优化后的四元式序列。

### 5\. 目标代码生成 (Code Generation)

  - **输入**: 优化后的四元式序列。
  - **处理**: `CodeGenerator` 模块遍历最终的四元式序列。对于每一条四元式，它会生成与之对应的、功能等价的一条或多条 x86 汇编指令。这包括变量的内存分配、寄存器管理、算术运算和控制流跳转等。
  - **输出**: 一个名为 `output.s` 的文本文件，其中包含 x86 汇编代码。

-----

## 如何构建与运行

### 环境依赖

  - **CMake**: 版本 3.10 或更高。
  - **C++ 编译器**: 支持 C++17 标准的编译器（如 GCC, Clang）。
  - **Make** 或其他构建工具 (如 Ninja)。
  - **(可选) IDE**: CLion 或 Visual Studio Code (with CMake Tools) 可以简化构建过程。
  - **Ps、本人运行时环境**：CLion2025.3.4—— 21.0.6+8-b631.39 aarch64 (JCEF 122.1.9)VM: OpenJDK 64-Bit Server VM，JetBrains s.r.o.
  - **汇编语言**：MASM6.11版本下的intel x86 16位汇编

### 构建步骤

在项目根目录下，执行以下命令：

```bash
# 1. 创建一个构建目录
mkdir build

# 2. 进入构建目录
cd build

# 3. 运行 CMake 来配置项目
cmake ..

# 4. 使用 Make 来编译项目
make
```

成功后，`build` 目录下会生成一个名为 `complier_anchor` 的可执行文件。

### 运行步骤

1.  **运行编译器**:

    ```bash
    # 在 build 目录下执行
    ./complier_anchor
    ```

    程序会弹出一个图形化文件选择框，请选择一个用 Anchor 语言编写的源文件（`.txt` 或其他后缀均可）。

2.  **查看汇编输出**:
    编译成功后，在您运行可执行文件的目录（即 `build` 目录）下会生成一个 `output.s` 文件。这就是编译器产生的汇编代码。

3.  **汇编和链接 (以 GCC 为例)**:
    打开终端，使用 GCC（或 Clang）将生成的汇编文件编译成最终的可执行程序。

    ```bash
    # 使用 gcc 将 .s 文件汇编并链接成可执行文件 final_program
    gcc -o final_program output.s
    ```

4.  **执行最终程序**:

    ```bash
    ./final_program
    ```

<!-- end list -->

```
```
